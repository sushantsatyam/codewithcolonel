# codewithcolonel

This repo is my **one project a day** portfolio. I’m splitting the work into two main tracks so it’s easy to browse and I can keep my progress consistent.

## Branches (how I’m organizing this)

- **`ml-track`**: classic ML from basics to advanced.
- **`ai-llm-track`**: prompt engineering + agent execution patterns (sequential, parallel, tools, memory).

I’ll keep `main` as the index and put each daily project inside its track folder.

## AI/LLM track (first project)

- **Day 01:** Prompting styles + sequential/parallel execution
  - Folder: `ai-llm-track/day01_agent_prompting`
  - Tech: Python + OpenAI + notebook
- **Day 02:** Prompt chaining (planner → executor → critic)
  - Folder: `ai-llm-track/day02_prompt_chaining`
  - Tech: Python + OpenAI + notebook

## ML track (starter outline)

**Day 01:** Data cleaning + quick EDA  
- Folder: `ml-track/day01_eda_basics`

**Day 02:** Baseline model (logistic regression)  
- Folder: `ml-track/day02_baseline_model`

**Week 1: Basics**
1. Data cleaning + EDA
2. Baseline model (logistic regression)
3. Decision trees + comparison
4. Feature engineering
5. Hyperparameter tuning
6. Interpretability basics
7. End-to-end report

**Week 2: Intermediate**
8. Random Forest / XGBoost
9. Cross-validation + metrics
10. Class imbalance strategies
11. Pipelines (sklearn)
12. Time series basics
13. Clustering + PCA
14. Simple API deployment

**Week 3+: Advanced**
15. NLP text classification
16. Topic modeling
17. Recommender system
18. Intro deep learning
19. CNNs
20. Transfer learning
21+. Real-world case studies

## Daily schedule (starting tomorrow)

I’ll publish **one project per day**. This keeps the pace steady without overthinking each day.

- **Tomorrow (Day 1):** Data cleaning + quick EDA (`ml-track/day01_eda_basics`)
- **Day 2:** Baseline model (`ml-track/day02_baseline_model`)
- **Day 3+:** Continue the ML track plan above, then alternate with AI/LLM track days.

## Notes (written by me)

- I’m aiming for progress over perfection.
- Each folder should have a clear README, runnable code, and a short demo output.
